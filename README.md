# Into Phoenix from ASP.NET Core 
[[toc]]

::: warning
We are not in any way, shape or form experts of either ASP.NET Forms/MVC/Core and or Elixir/Phoenix. Altough Elixir/Phoenix seems to be easier to learn than ASP.NET we are still learning how to use it properly.  
These pages are here just for our fellow .NET programers to learn this great framework for truly scalable applications.
:::

## Brief introduction and motivation
The main motivation for this small documentation is to help other ASP.NET Core developers to move to Phoenix and make this transition easier than it was to us.

If you have arrived here you probably already know why you want to use Phoenix Framework but you should prepare yourself for some bumpy ride. ASP.NET Core does a lot of work for you but that of course costs you something, performance.

In Phoenix your work is more streamlined but you have to do a lot of common tasks by yourself, for example to populate ``conn.current_user`` (in fact there is no current_user property of conn object, you have to create it in a plug). 

## Example application
To show differences in these two technologies we will create an example applications in both frameworks.

This example application called ShopToday will simulate product and order management, basically a simple e-shop. Data are stored in the database and some pages are rendered on server and some are generated by Javascript libraries.

Basic technical parameters of the example application are these:
- Single server application
  - For ASP.NET application we will use ASP.NET Core 3.x
  - For Phoenix application we will use Phoenix 1.4.x
- Forms authentication
- Server rendering of pages
- Serving static content, for example Javascript files and images
- API endpoints
- Communicating with PostgreSQL database
- Running background jobs for cleanup
- Websocket communication with connected clients

As an HTML framework we will use [bulma](https://bulma.io/). For Javascript content generation we will use [Svelte](https://svelte.dev) and [Elm](https://elm-lang.org). Data will be loaded with standard [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

For database communication from ASP.NET our team generaly uses [LLBLGen](https://llblgen.com), which in our opinion works better and faster than Entity Framework + it can generate stored procedures calls, but for this example application we will use Entity Framework to make it more accessible for others.

For database communication from Elixir there is no really any other option than Ecto and that is what we will use. It brings some interesting features like Out of the Box validation and "computed" changesets of your old data ane new data. Calling a stored procedure from Ecto seems to be a big pain in the code but we'll see.

For most of the work we will use Visual Studio 2017/9 and IntelliJ Idea.